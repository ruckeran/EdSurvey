varLabel = dat$Labels,
stringsAsFactors = FALSE)
valLabels <- data.frame(varName = dat_long2$varName,
value = dat_long2$value,
valLabel = dat_long2$valLabel,
missings = dat_long2$missings,
stringsAsFactors = FALSE)
vars <- pisa_list2$`2000`$dataList$Student$fileFormat$variableName # Saving variable names out of fileFormat
vars_unique <- unique(vars) # Making varnames unique
n <- length(vars_unique) # How many elements do we need for the data frame
df <- as.data.frame(
setNames(replicate(n, character(0), simplify = FALSE), vars_unique),
stringsAsFactors = FALSE
)
valLabels2 <- valLabels
valLabels2$value <- as.numeric(valLabels2$value)
table(valLabels$value[is.na(valLabels2$value)], valLabels2$value[is.na(valLabels2$value)],
useNA = "if")
View(dat_long)
View(dat_long2)
# Keeping only necessary columns for GADSdat
dat_long2 <- dat_long %>%
select(any_of(c("varName", "varLabel", "value", "valLabel", "missings")))
### 1. Splitting labelValues at "^"
dat <- pisa_list2$`2000`$dataList$Student$fileFormat
max_parts <- max(sapply(strsplit(dat$labelValues, "\\^"), length), na.rm = TRUE) # Determine the number of parts per line
into <- paste0("val", seq_len(max_parts)) # Generate and separate column names
dat_wide <- tidyr::separate(dat, labelValues, into = into, sep = "\\^", fill = "right")
### 2. Converting dat into long format (and splitting values and value labels)
dat_long <- dat_wide |>
pivot_longer(cols = starts_with("val"),
names_to = "valnum",
values_to = "pair",
values_drop_na = TRUE) |>
separate(pair, into = c("code", "label"),
sep = "=", fill = "right")
# Renaming the columns for GADSdat
dat_long <- dat_long %>%
rename(varName = variableName,
varLabel = Labels,
value   = code,
valLabel = label)
# Creating new missing tags
dat_long$missings <- mapply(function(val, miss_str) {
val_chr <- as.character(val)
if (is.na(val) || trimws(val_chr) == "") return(NA_character_) # If the value itself is missing or only contains spaces -> NA
val_trim <- trimws(val_chr)
if (is.na(miss_str) || trimws(as.character(miss_str)) == "") {
return(if (val_trim %in% c("n", "r")) "miss" else "valid") # Tag "n" and "r" as Missings
}
miss_vals <- unlist(strsplit(as.character(miss_str), "[;,\\s]+"))
miss_vals <- trimws(gsub("^['\"]|['\"]$", "", miss_vals))
if (val_trim %in% miss_vals || val_trim %in% c("n", "r")) "miss" else "valid"
}, dat_long$value, dat_long$missing, USE.NAMES = FALSE)
# Keeping only necessary columns for GADSdat
dat_long2 <- dat_long %>%
select(any_of(c("varName", "varLabel", "value", "valLabel", "missings")))
# Keeping only necessary columns for GADSdat
dat_long2 <- dat_long %>%
select(c("varName", "varLabel", "value", "valLabel", "missings"))
# Creating new missing tags (with the help of dat_long$value and dat_long$missing)
dat_long$missings <- mapply(function(val, miss_str) {
val_chr <- as.character(val) # Ensuring the incoming value is treated as a character string
if (is.na(val) || trimws(val_chr) == "") return(NA_character_) # If the value itself is missing or only contains spaces -> NA
val_trim <- trimws(val_chr) # Trimming whitespaces
if (is.na(miss_str) || trimws(as.character(miss_str)) == "") {
return(if (val_trim %in% c("n", "r")) "miss" else "valid") # Tagging "n" and "r" as Missings
}
miss_vals <- unlist(strsplit(as.character(miss_str), "[;,\\s]+")) # If a missing-definition string exists, split it into individual codes
#miss_vals <- trimws(gsub("^['\"]|['\"]$", "", miss_vals))
if (val_trim %in% miss_vals || val_trim %in% c("n", "r")) "miss" else "valid"
}, dat_long$value, dat_long$missing, USE.NAMES = FALSE)
# Keeping only necessary columns for GADSdat
dat_long2 <- dat_long %>%
select(c("varName", "varLabel", "value", "valLabel", "missings"))
# Creating new missing tags (with the help of dat_long$value and dat_long$missing)
dat_long$missings <- mapply(function(val, miss_str) {
val_chr <- as.character(val) # Ensuring the incoming value is treated as a character string
if (is.na(val) || trimws(val_chr) == "") return(NA_character_) # If the value itself is missing or only contains spaces -> NA
#val_chr <- trimws(val_chr) # Trimming whitespaces
if (is.na(miss_str) || trimws(as.character(miss_str)) == "") {
return(if (val_chr %in% c("n", "r")) "miss" else "valid") # Tagging "n" and "r" as Missings
}
miss_vals <- unlist(strsplit(as.character(miss_str), "[;,\\s]+")) # If a missing-definition string exists, split it into individual codes
if (val_chr %in% miss_vals || val_chr %in% c("n", "r")) "miss" else "valid"
}, dat_long$value, dat_long$missing, USE.NAMES = FALSE)
# Keeping only necessary columns for GADSdat
dat_long2 <- dat_long %>%
select(c("varName", "varLabel", "value", "valLabel", "missings"))
View(dat_long2)
View(dat_long)
# Creating new missing tags (with the help of the variables dat_long$value and dat_long$missing)
dat_long$missings <- mapply(function(val, miss_str) {
val_chr <- as.character(val) # Ensuring the incoming value is treated as a character string
if (is.na(val) || trimws(val_chr) == "") return(NA_character_) # If the value itself is missing or only contains spaces -> NA
# if (is.na(miss_str) || trimws(as.character(miss_str)) == "") {
#   return(if (val_chr %in% c("n", "r")) "miss" else "valid") # Tagging "n" and "r" as Missings
}
miss_vals <- unlist(strsplit(as.character(miss_str), "[;,\\s]+")) # If a missing-definition string exists, splitting it into individual codes
# Creating new missing tags (with the help of the variables dat_long$value and dat_long$missing)
dat_long$missings <- mapply(function(val, miss_str) {
val_chr <- as.character(val) # Ensuring the incoming value is treated as a character string
if (is.na(val) || trimws(val_chr) == "") return(NA_character_) # If the value itself is missing or only contains spaces -> NA
# if (is.na(miss_str) || trimws(as.character(miss_str)) == "") {
#   return(if (val_chr %in% c("n", "r")) "miss" else "valid") # Tagging "n" and "r" as Missings
# }
miss_vals <- unlist(strsplit(as.character(miss_str), "[;,\\s]+")) # If a missing-definition string exists, splitting it into individual codes
if (val_chr %in% miss_vals || val_chr %in% c("n", "r")) "miss" else "valid"
}, dat_long$value, dat_long$missing, USE.NAMES = FALSE)
# Keeping only necessary columns for GADSdat
dat_long2 <- dat_long %>%
select(c("varName", "varLabel", "value", "valLabel", "missings"))
View(dat_long2)
# Keeping only necessary columns for GADSdat
dat_long2 <- dat_long %>%
select(c("varName", "varLabel", "value", "valLabel", "missings"))
### 3. Preparing meta data and data for GADSdat
varLabels <- data.frame(varName = dat$variableName,
varLabel = dat$Labels,
stringsAsFactors = FALSE)
valLabels <- data.frame(varName = dat_long2$varName,
value = dat_long2$value,
valLabel = dat_long2$valLabel,
missings = dat_long2$missings,
stringsAsFactors = FALSE)
vars <- pisa_list2$`2000`$dataList$Student$fileFormat$variableName # Saving variable names out of fileFormat
vars_unique <- unique(vars) # Making varnames unique
n <- length(vars_unique) # How many elements do we need for the data frame
df <- as.data.frame(
setNames(replicate(n, character(0), simplify = FALSE), vars_unique),
stringsAsFactors = FALSE
)
valLabels2 <- valLabels
valLabels2$value <- as.numeric(valLabels2$value)
table(valLabels$value[is.na(valLabels2$value)], valLabels2$value[is.na(valLabels2$value)],
useNA = "if")
valLabels2 <- valLabels
valLabels2$value <- as.numeric(valLabels2$value)
df <- as.data.frame(
setNames(replicate(n, character(0), simplify = FALSE), vars_unique),
stringsAsFactors = FALSE
)
# --------------------------------------------------------------------------------------------------
# -------- Syntax for downloading and reading in OECD PISA data directly from their website --------
# --------------------------------------------------------------------------------------------------
# Packages needed ----------------------------------------------------------------------------------
library(readr)
library(eatGADS)
library(devtools)
devtools::load_all()
0
library(readr)
library(eatGADS)
library(devtools)
devtools::load_all()
library(EdSurvey)
downloadPISA(root = "C:/Users/ruckeran/Downloads", years = c(2000, 2003, 2006, 2009, 2012), database = "INT")
years <- c("2000","2003","2006","2009","2012")
base  <- "C:/Users/ruckeran/Downloads/PISA"
# reading individually, using forceReread to ensure that everything is freshly read in
pisa_list2 <- setNames(lapply(years, function(yr) {
cat("\n--- Reading PISA", yr, "---\n")
readPISA(path = file.path(base, yr),
countries = "deu",
cognitive = "score",
forceReread = TRUE)
}), years)
library(tidyr)
library(dplyr)
dat <- pisa_list2$`2000`$dataList$Student$fileFormat
max_parts <- max(sapply(strsplit(dat$labelValues, "\\^"), length), na.rm = TRUE) # Determine the number of parts per line
into <- paste0("val", seq_len(max_parts)) # Generate and separate column names
dat_wide <- tidyr::separate(dat, labelValues, into = into, sep = "\\^", fill = "right")
dat_long <- dat_wide |>
pivot_longer(cols = starts_with("val"),
names_to = "valnum",
values_to = "pair",
values_drop_na = TRUE) |>
separate(pair, into = c("code", "label"),
sep = "=", fill = "right")
# Renaming the columns for GADSdat
dat_long <- dat_long %>%
rename(varName = variableName,
varLabel = Labels,
value   = code,
valLabel = label)
# Creating new missing tags (with the help of the variables dat_long$value and dat_long$missing)
dat_long$missings <- mapply(function(val, miss_str) {
val_chr <- as.character(val) # Ensuring the incoming value is treated as a character string
if (is.na(val) || trimws(val_chr) == "") return(NA_character_) # If the value itself is missing or only contains spaces -> NA
miss_vals <- unlist(strsplit(as.character(miss_str), "[;,\\s]+")) # If a missing-definition string exists, splitting it into individual codes
if (val_chr %in% miss_vals || val_chr %in% c("n", "r")) "miss" else "valid"
}, dat_long$value, dat_long$missing, USE.NAMES = FALSE)
# Keeping only necessary columns for GADSdat
dat_long2 <- dat_long %>%
select(c("varName", "varLabel", "value", "valLabel", "missings"))
varLabels <- data.frame(varName = dat$variableName,
varLabel = dat$Labels,
stringsAsFactors = FALSE)
valLabels <- data.frame(varName = dat_long2$varName,
value = dat_long2$value,
valLabel = dat_long2$valLabel,
missings = dat_long2$missings,
stringsAsFactors = FALSE)
vars <- pisa_list2$`2000`$dataList$Student$fileFormat$variableName # Saving variable names out of fileFormat
vars_unique <- unique(vars) # Making varnames unique
n <- length(vars_unique) # How many elements do we need for the data frame
df <- as.data.frame(
setNames(replicate(n, character(0), simplify = FALSE), vars_unique),
stringsAsFactors = FALSE
)
valLabels2 <- valLabels
valLabels2$value <- as.numeric(valLabels2$value)
## error hunt following
table(valLabels$value[is.na(valLabels2$value)], valLabels2$value[is.na(valLabels2$value)],
useNA = "if")
View(pisa_list2)
pisa_list2$`2000`$dataList$Student$fileFormat
View(pisa_list2$`2000`$dataList$Student$fileFormat)
dat <- pisa_list2$`2000`$dataList$Student$fileFormat
dat_wide2 <- tidyr::separate(dat, labelValues, sep = "\\^", fill = "right")
?tidyr::separate
tidyr::separate
dat$labelValues
dat$labelValues[1:10]
dat$labelValues[2]
grep("^", dat$labelValues[2])
?grep
?pmatch
pmatch("^", dat$labelValues[2])
pmatch("^", dat$labelValues[2], duplicates.ok = TRUE)
stringr::str_count("^", dat$labelValues[2])
stringr::str_count("\\^", dat$labelValues[2])
stringr::str_count(dat$labelValues[2], pattern = "^")
stringr::str_count(dat$labelValues[2], pattern = "\\^")
dat <- pisa_list2$`2000`$dataList$Student$fileFormat
max_parts <- max(sapply(strsplit(dat$labelValues, "\\^"), length), na.rm = TRUE) # Determine the number of parts per line
into <- paste0("val", seq_len(max_parts)) # Generate and separate column names
dat_wide <- tidyr::separate(dat, labelValues, into = into, sep = "\\^", fill = "right")
str(dat_wide)
dat_long <- dat_wide |>
pivot_longer(cols = starts_with("val"),
names_to = "valnum",
values_to = "pair",
values_drop_na = TRUE) |>
separate(pair, into = c("code", "label"),
sep = "=", fill = "right")
str(dat_long)
# Renaming the columns for GADSdat
dat_long <- dat_long %>%
rename(varName = variableName,
varLabel = Labels,
value   = code,
valLabel = label)
str(dat_long)
dat_long$missing
varLabels <- data.frame(varName = dat$variableName,
varLabel = dat$Labels,
stringsAsFactors = FALSE)
valLabels <- data.frame(varName = dat_long2$varName,
value = dat_long2$value,
valLabel = dat_long2$valLabel,
missings = dat_long2$missings,
stringsAsFactors = FALSE)
vars <- pisa_list2$`2000`$dataList$Student$fileFormat$variableName # Saving variable names out of fileFormat
vars
any(duplicated(vars))
?setNames
setNames(replicate(n, character(0), simplify = FALSE), vars_unique)
lapply(vars_unique, character)
lapply(vars_unique, character(0))
lapply(vars_unique, character, 0
)
?character
lapply(vars_unique, character, length = 0)
vars_unique
lapply(vars_unique, character, length = 0)
lapply(vars_unique, FUN = character, length = 0)
?lapply
lapply(X = vars_unique, FUN = character, length = 0)
lapply(vars_unique, function(x) character(0))
lapply(vars_unique, function(x) character(0))
as.data.frame(lapply(vars_unique, function(x) character(0)))
df2 <- as.data.frame(lapply(vars_unique, function(x) character(0)))
names(df2) <- vars_unique
all.equal(df, df2)
valLabels2 <- valLabels
df <- as.data.frame(
setNames(replicate(n, character(0), simplify = FALSE), vars_unique),
stringsAsFactors = FALSE
)
valLabels2 <- valLabels
valLabels2$value <- as.numeric(valLabels2$value)
## error hunt following
table(valLabels$value[is.na(valLabels2$value)], valLabels2$value[is.na(valLabels2$value)],
useNA = "if")
valLabels2$value <- as.numeric(valLabels2$value)
## error hunt following
table(valLabels$value[is.na(valLabels2$value)], valLabels2$value[is.na(valLabels2$value)],
useNA = "if")
valLabels2$value <- as.numeric(valLabels2$value)
## error hunt following
table(valLabels$value[is.na(valLabels2$value)], valLabels2$value[is.na(valLabels2$value)],
useNA = "if")
gads <- import_raw(df = df, varLabels = varLabels, valLabels = valLabels,
checkVarNames = FALSE)  # Creating GADSdat
valLabels2$value <- as.numeric(valLabels2$value)
## error hunt following
table(valLabels$value[is.na(valLabels2$value)], valLabels2$value[is.na(valLabels2$value)],
useNA = "if")
gads <- import_raw(df = df, varLabels = varLabels, valLabels = valLabels,
checkVarNames = FALSE)  # Creating GADSdat
df <- tibble(
country = c("ALB", "ARG", "AUS", "AUT", "BEL"),
value = c(1, 1, 1, 1, 1)
)
# Add variable and value labels
var_label(df$country) <- "Country code"
library(labelled)
# Add variable and value labels
var_label(df$country) <- "Country code"
val_labels(df$country) <- c(
ALB = "Albania",
ARG = "Argentina",
AUS = "Australia",
AUT = "Austria",
BEL = "Belgium"
)
# Save as temporary SPSS file
tmpfile <- tempfile(fileext = ".sav")
write_sav(df, tmpfile)
library(eatGADS)
library(haven)
library(labelled)
library(dplyr)
write_sav(df, tmpfile)
# Try to import with eatGADS
test_gads <- importSPSS(tmpfile)
library(eatGADS)
# Try to import with eatGADS
test_gads <- import_spss(tmpfile)
# Inspect imported data
extractData(test_gads)
# or alternatively:
test_gads <- import_raw(tmpfile)
df <- data.frame(
country = c("ALB", "ARG", "AUS", "AUT", "BEL"),
value = c(1, 1, 1, 1, 1)
)
# Add variable and value labels
var_label(df$country) <- "Country code"
val_labels(df$country) <- c(
ALB = "Albania",
ARG = "Argentina",
AUS = "Australia",
AUT = "Austria",
BEL = "Belgium"
)
# Save as temporary SPSS file
tmpfile <- tempfile(fileext = ".sav")
write_sav(df, tmpfile)
# or alternatively:
test_gads <- import_raw(tmpfile)
library(labelled)
library(eatGADS)
# Create a data frame similar to what would come from SPSS
df <- data.frame(
country = c("ALB", "ARG", "AUS", "AUT", "BEL"),
value = c(1, 1, 1, 1, 1),
stringsAsFactors = FALSE
)
# Add variable label
var_label(df$country) <- "Country code"
var_label(df$value) <- "Numeric value"
# Add value labels (these are STRING labels)
val_labels(df$country) <- c(
ALB = "Albania",
ARG = "Argentina",
AUS = "Australia",
AUT = "Austria",
BEL = "Belgium"
)
# Check labelled structure
str(df)
print(val_labels(df$country))
# ---- Try importing into eatGADS manually ----
# eatGADS expects a data frame and a valLabels data.frame
# similar to what import_raw() builds internally
# Create the corresponding value label table manually
valLabels <- data.frame(
varName = "country",
value = c("ALB", "ARG", "AUS", "AUT", "BEL"),
valLabel = c("Albania", "Argentina", "Australia", "Austria", "Belgium"),
missings = NA_character_,
stringsAsFactors = FALSE
)
# This mimics the structure that import_raw() would validate:
print(valLabels)
# If you run:
# check_valLabels(df = df, valLabels = valLabels)
# youâ€™ll see the same numeric-value error
# ---- Inspect what happens ----
try(eatGADS:::check_valLabels(df = df, valLabels = valLabels))
library(labelled)
library(eatGADS)
# Create a data frame similar to what would come from SPSS
df <- data.frame(
country = c("ALB", "ARG", "AUS", "AUT", "BEL"),
value = c(1, 1, 1, 1, 1),
stringsAsFactors = FALSE
)
# Add variable label
var_label(df$country) <- "Country code"
var_label(df$value) <- "Numeric value"
# Add value labels (these are STRING labels)
val_labels(df$country) <- c(
ALB = "Albania",
ARG = "Argentina",
AUS = "Australia",
AUT = "Austria",
BEL = "Belgium"
)
# Check labelled structure
str(df)
print(val_labels(df$country))
# Create the corresponding value label table manually
valLabels <- data.frame(
varName = "country",
value = c("ALB", "ARG", "AUS", "AUT", "BEL"),
valLabel = c("Albania", "Argentina", "Australia", "Austria", "Belgium"),
missings = NA_character_,
stringsAsFactors = FALSE
)
# This mimics the structure that import_raw() would validate:
print(valLabels)
# ---- Inspect what happens ----
try(eatGADS:::check_valLabels(df = df, valLabels = valLabels))
gads <- import_raw(df = df, varLabels = varLabels, valLabels = valLabels,
checkVarNames = FALSE)
# Create the corresponding value label table manually
dat <- data.frame(
varName = "country",
value = c("ALB", "ARG", "AUS", "AUT", "BEL"),
valLabel = c("Albania", "Argentina", "Australia", "Austria", "Belgium"),
missings = NA_character_,
stringsAsFactors = FALSE
)
gads <- import_raw(df = dat, varLabels = varLabels, valLabels = valLabels,
checkVarNames = FALSE)
df <- data.frame(
country = c("ALB", "ARG", "AUS", "AUT", "BEL"),
value = c(1, 1, 1, 1, 1),
stringsAsFactors = FALSE
)
val_labels(df$country) <- c(
ALB = "Albania",
ARG = "Argentina",
AUS = "Australia",
AUT = "Austria",
BEL = "Belgium"
)
View(df)
valLabels <- data.frame(
varName = "country",
value = c("ALB", "ARG", "AUS", "AUT", "BEL"),
valLabel = c("Albania", "Argentina", "Australia", "Austria", "Belgium"),
missings = NA_character_,
stringsAsFactors = FALSE
)
gads <- import_raw(df = dat, varLabels = varLabels, valLabels = valLabels,
checkVarNames = FALSE)
gads <- import_raw(df = dat, valLabels = valLabels,
checkVarNames = FALSE)
varLabels <- data.frame(varName = "country",
varLabel = "Land",
stringsAsFactors = FALSE)
valLabels <- data.frame(
varName = "country",
value = c("ALB", "ARG", "AUS", "AUT", "BEL"),
valLabel = c("Albania", "Argentina", "Australia", "Austria", "Belgium"),
missings = NA_character_,
stringsAsFactors = FALSE
)
gads <- import_raw(df = dat, varLabels = varLabels, valLabels = valLabels,
checkVarNames = FALSE)
View(df)
varLabels <- data.frame(varName = c("country", "value"),
varLabel = c("Land", "test"),
stringsAsFactors = FALSE)
valLabels <- data.frame(
varName = "country",
value = c("ALB", "ARG", "AUS", "AUT", "BEL"),
valLabel = c("Albania", "Argentina", "Australia", "Austria", "Belgium"),
missings = NA_character_,
stringsAsFactors = FALSE
)
gads <- import_raw(df = dat, varLabels = varLabels, valLabels = valLabels,
checkVarNames = FALSE)
gads <- import_raw(df = df, varLabels = varLabels, valLabels = valLabels,
checkVarNames = FALSE)
varLabels <- data.frame(varName = "country",
varLabel = "Land",
stringsAsFactors = FALSE)
valLabels <- data.frame(
varName = "country",
value = c("ALB", "ARG", "AUS", "AUT", "BEL"),
valLabel = c("Albania", "Argentina", "Australia", "Austria", "Belgium"),
missings = NA_character_,
stringsAsFactors = FALSE
)
gads <- import_raw(df = df, varLabels = varLabels, valLabels = valLabels,
checkVarNames = FALSE)
